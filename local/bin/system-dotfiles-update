#!/bin/bash
#
# Update dotfiles from remote repository
# Usage: system-dotfiles-update [--dry-run]
#
set -e

# Source helper functions
source "$HOME/.local/lib/shell/common.sh"

# Parse arguments
DRY_RUN=0
while [[ $# -gt 0 ]]; do
    case $1 in
    --dry-run)
        DRY_RUN=1
        shift
        ;;
    *)
        echo "Unknown option: $1"
        echo "Usage: system-dotfiles-update [--dry-run]"
        exit 1
        ;;
    esac
done

# Ensure DOTFILES_DIR is set
if [[ -z "$DOTFILES_DIR" || ! -d "$DOTFILES_DIR" ]]; then
    echo "Error: DOTFILES_DIR not"
    echo "Please set DOTFILES_DIR environment variable"
    exit 1
fi

# Ensure we're in dotfiles directory
cd "$DOTFILES_DIR"

# ==== Header ====
if [[ $DRY_RUN -eq 1 ]]; then
    gum_header "Dotfiles Update (Dry Run)" "Checking for updates without applying changes"
else
    gum_header "Dotfiles Update" "Checking for updates from remote repository"
fi
echo

# ==== Check for uncommitted changes ====
gum_section "Checking working directory status..."
if [[ -n $(git status --porcelain) ]]; then
    gum_warning "You have uncommitted changes in your dotfiles!"
    echo
    git status --short
    echo

    gum_info "Choose an option:"
    CHOICE=$(gum choose "Abort update" "Stash changes and continue" "Try again (fix manually)")

    case "$CHOICE" in
    "Abort update")
        gum_info "Update cancelled"
        exit 0
        ;;
    "Stash changes and continue")
        gum_info "Stashing changes..."
        git stash push -m "Auto-stash before dotfiles update $(date +%Y-%m-%d_%H:%M:%S)"
        STASHED=1
        gum_success "Changes stashed"
        echo
        ;;
    "Try again (fix manually)")
        gum_info "Please fix the issues in another terminal, then press Enter"
        read -p ""

        # Re-check
        if [[ -n $(git status --porcelain) ]]; then
            gum_error "Working directory still has changes. Aborting."
            exit 1
        fi
        gum_success "Working directory is clean"
        echo
        ;;
    esac
else
    gum_success "Working directory is clean"
    echo
fi

# ==== Fetch updates ====
gum_section "Fetching updates from remote..."
if ! git fetch origin 2>&1 | grep -q "fatal"; then
    gum_success "Fetch completed"
else
    gum_error "Failed to fetch from remote"
    exit 1
fi
echo

# ==== Check current branch ====
CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)
gum_info "Current branch: $CURRENT_BRANCH"

# ==== Check for updates ====
UPSTREAM="origin/$CURRENT_BRANCH"

# Check if upstream exists
if ! git rev-parse "$UPSTREAM" &>/dev/null; then
    gum_warning "No upstream branch found for '$CURRENT_BRANCH'"
    gum_info "Your branch may not be tracking a remote branch"
    exit 0
fi

# Compare with upstream
LOCAL=$(git rev-parse @)
REMOTE=$(git rev-parse "$UPSTREAM")
BASE=$(git merge-base @ "$UPSTREAM")

if [[ "$LOCAL" == "$REMOTE" ]]; then
    gum_success "Dotfiles are already up to date!"
    exit 0
elif [[ "$LOCAL" == "$BASE" ]]; then
    # We're behind, can fast-forward
    COMMITS_BEHIND=$(git rev-list --count "$LOCAL..$REMOTE")
    gum_info "Updates available: $COMMITS_BEHIND new commit(s)"
    echo

    # Show commit summary
    gum_section "Recent changes:"
    gum_box "$(git log --oneline --decorate --color=always "$LOCAL..$REMOTE")"
    echo

    # Show detailed changes if requested
    if gum_confirm "Show detailed commit messages?"; then
        echo
        git log --pretty=format:"%C(yellow)%h%C(reset) - %C(green)(%ar)%C(reset) %s %C(blue)- %an%C(reset)" "$LOCAL..$REMOTE"
        echo
        echo
    fi

    if [[ $DRY_RUN -eq 1 ]]; then
        gum_info "Dry run mode: Would pull $COMMITS_BEHIND commit(s)"
        exit 0
    fi

    # Confirm update
    if ! gum_confirm "Apply these updates?"; then
        gum_info "Update cancelled"
        exit 0
    fi
    
    # Capture current commit before pulling
    OLD_COMMIT=$(git rev-parse HEAD)
    
    # Pull updates
    echo
    gum_section "Pulling updates..."
    if git pull origin "$CURRENT_BRANCH"; then
        gum_success "Successfully pulled updates"
        echo
        
        # Capture new commit after pulling
        NEW_COMMIT=$(git rev-parse HEAD)
        
        # Run post-update script with commit range
        gum_section "Applying configuration changes..."
        if [[ -f "$DOTFILES_DIR/install/dotfiles-update.sh" ]]; then
            bash "$DOTFILES_DIR/install/dotfiles-update.sh" "$OLD_COMMIT" "$NEW_COMMIT"
        else
            gum_warning "Post-update script not found, skipping"
        fi

        # Pop stash if we stashed earlier
        if [[ "${STASHED:-0}" -eq 1 ]]; then
            echo
            gum_section "Restoring stashed changes..."
            if gum_confirm "Pop your stashed changes?"; then
                if git stash pop; then
                    gum_success "Stashed changes restored"
                else
                    gum_warning "Failed to pop stash (may have conflicts)"
                    gum_info "You can manually apply with: git stash pop"
                fi
            else
                gum_info "Stash preserved. Apply later with: git stash pop"
            fi
        fi

        echo
        gum_success "Dotfiles update complete!"
        gum_show
    else
        gum_error "Failed to pull updates"
        exit 1
    fi

elif [[ "$REMOTE" == "$BASE" ]]; then
    # We're ahead of remote
    COMMITS_AHEAD=$(git rev-list --count "$REMOTE..$LOCAL")
    gum_info "Your dotfiles are $COMMITS_AHEAD commit(s) ahead of remote"
    gum_info "Consider pushing your changes with: git push"
    exit 0
else
    # Diverged
    gum_warning "Your branch has diverged from remote!"
    COMMITS_AHEAD=$(git rev-list --count "$REMOTE..$LOCAL")
    COMMITS_BEHIND=$(git rev-list --count "$LOCAL..$REMOTE")
    gum_info "You are $COMMITS_AHEAD commit(s) ahead and $COMMITS_BEHIND commit(s) behind"
    gum_info "Please resolve manually with: git pull --rebase or git merge"
    exit 1
fi
