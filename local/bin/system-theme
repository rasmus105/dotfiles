#!/usr/bin/env bash
set -euo pipefail

#──────────────────────────────────────────────────────────────────────────────
# Setup
#──────────────────────────────────────────────────────────────────────────────

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "${SCRIPT_DIR}/../lib/shell/common.sh" 2>/dev/null || q() { "$@" >/dev/null 2>&1; }

THEMES_DIR="$HOME/.config/themes"
CURRENT_THEME_DIR="$HOME/.config/theme"
THEME_BACKGROUNDS="$HOME/.config/theme/backgrounds"
HYPR_BACKGROUND="$HOME/.config/hypr/background.jpg"

#──────────────────────────────────────────────────────────────────────────────
# Functions
#──────────────────────────────────────────────────────────────────────────────

main() {
    parse_args "$@"
}

parse_args() {
    [[ $# -gt 0 ]] || {
        print_help
        exit 0
    }

    local action="$1"
    shift

    case "$action" in
    set)
        [[ $# -eq 1 ]] || {
            echo "Error: set requires exactly one theme name" >&2
            exit 1
        }
        set_theme "$1"
        ;;
    get)
        [[ $# -eq 0 ]] || {
            echo "Error: get takes no arguments" >&2
            exit 1
        }
        print_theme
        ;;
    background | bg)
        parse_background_args "$@"
        ;;
    font)
        parse_font_args "$@"
        ;;
    nightlight)
        [[ $# -eq 0 ]] || {
            echo "Error: nightlight takes no arguments" >&2
            exit 1
        }
        toggle_nightlight
        ;;
    --help | -h | help)
        [[ $# -eq 0 ]] || {
            echo "Error: help takes no arguments" >&2
            exit 1
        }
        print_help
        ;;
    *)
        echo "Error: Unknown action: $action" >&2
        print_help
        exit 1
        ;;
    esac
}

parse_background_args() {
    [[ $# -gt 0 ]] || {
        echo "Error: background requires an action" >&2
        print_background_help
        exit 1
    }

    local bg_action="$1"
    shift

    case "$bg_action" in
    shuffle)
        [[ $# -eq 0 ]] || {
            echo "Error: shuffle takes no arguments" >&2
            exit 1
        }
        shuffle_background
        ;;
    next)
        [[ $# -eq 0 ]] || {
            echo "Error: next takes no arguments" >&2
            exit 1
        }
        next_background
        ;;
    set)
        [[ $# -eq 1 ]] || {
            echo "Error: set requires image path" >&2
            exit 1
        }
        set_background "$1"
        ;;
    get)
        [[ $# -eq 0 ]] || {
            echo "Error: get takes no arguments" >&2
            exit 1
        }
        get_background
        ;;
    --help | -h | help)
        [[ $# -eq 0 ]] || {
            echo "Error: help takes no arguments" >&2
            exit 1
        }
        print_background_help
        ;;
    *)
        echo "Error: Unknown background action: $bg_action" >&2
        print_background_help
        exit 1
        ;;
    esac
}

parse_font_args() {
    [[ $# -gt 0 ]] || {
        echo "Error: font requires an action" >&2
        print_font_help
        exit 1
    }

    local font_action="$1"
    shift

    case "$font_action" in
    set)
        [[ $# -eq 1 ]] || {
            echo "Error: set expects 1 argument" >&2
            exit 1
        }
        set_font "$1"
        ;;
    get)
        [[ $# -eq 0 ]] || {
            echo "Error: get takes no arguments" >&2
            exit 1
        }
        get_font
        ;;
    list)
        [[ $# -eq 0 ]] || {
            echo "Error: list takes no arguments" >&2
            exit 1
        }
        list_fonts
        ;;
    --help | -h | help)
        [[ $# -eq 0 ]] || {
            echo "Error: help takes no arguments" >&2
            exit 1
        }
        print_font_help
        ;;
    *)
        echo "Error: Unknown font action: $font_action" >&2
        print_font_help
        exit 1
        ;;
    esac
}

#──────────────────────────────────────────────────────────────────────────────
# Theme Functions
#──────────────────────────────────────────────────────────────────────────────

set_theme() {
    local theme_name="$1"

    [[ -d "$THEMES_DIR/$theme_name" ]] || {
        echo "Error: Theme '$theme_name' not found" >&2
        echo "Available themes:" >&2
        ls "$THEMES_DIR" >&2 2>/dev/null || echo "  (No themes directory found)" >&2
        return 1
    }

    # Set theme symlink
    q ln -nsf "$THEMES_DIR/$theme_name" "$CURRENT_THEME_DIR"

    # Apply theme configurations
    apply_theme_configs

    # Refresh applications to reload configurations
    if command -v system-refresh &>/dev/null; then
        system-refresh theme
    else
        echo "Warning: system-refresh not found, theme applied but apps not refreshed" >&2
    fi

    echo "Theme set to $theme_name"
}

apply_theme_configs() {
    apply_nvim_theme
    apply_zathura_theme
    apply_gnome_theme
    apply_browser_theme
}

apply_nvim_theme() {
    local theme_neovim="$CURRENT_THEME_DIR/neovim.lua"
    local nvim_theme_file="$HOME/.config/nvim/theme.lua"

    if [[ -f "$theme_neovim" ]]; then
        q ln -sf "$theme_neovim" "$nvim_theme_file" || true
    fi
}

apply_zathura_theme() {
    local theme_zathura="$CURRENT_THEME_DIR/zathura.theme"
    local zathura_theme_file="$HOME/.config/zathura/theme.zathurarc"

    if [[ -f "$theme_zathura" ]]; then
        q ln -sf "$theme_zathura" "$zathura_theme_file" || true
    fi
}

apply_gnome_theme() {
    # Set color scheme based on light/dark mode
    if [[ -f "$CURRENT_THEME_DIR/light.mode" ]]; then
        q gsettings set org.gnome.desktop.interface color-scheme "prefer-light" || true
        q gsettings set org.gnome.desktop.interface gtk-theme "Adwaita" || true
    else
        q gsettings set org.gnome.desktop.interface color-scheme "prefer-dark" || true
        q gsettings set org.gnome.desktop.interface gtk-theme "Adwaita-dark" || true
    fi

    # Set icon theme if specified
    local icons_theme="$CURRENT_THEME_DIR/icons.theme"
    if [[ -f "$icons_theme" ]]; then
        q gsettings set org.gnome.desktop.interface icon-theme "$(<"$icons_theme")" || true
    else
        q gsettings set org.gnome.desktop.interface icon-theme "Yaru-blue" || true
    fi
}

apply_browser_theme() {
    local browser_theme="$CURRENT_THEME_DIR/browser.theme"

    # Only proceed if chromium or helium-browser is installed
    if ! command -v chromium &>/dev/null && ! command -v helium-browser &>/dev/null; then
        return 0
    fi

    # Read theme color or use default
    local theme_rgb_color theme_hex_color
    if [[ -f "$browser_theme" ]]; then
        theme_rgb_color=$(<"$browser_theme")
        theme_hex_color=$(printf '#%02x%02x%02x' ${theme_rgb_color//,/ })
    else
        theme_rgb_color="28,32,39"
        theme_hex_color="#1c2027"
    fi

    # Update chromium
    if command -v chromium &>/dev/null; then
        q rm -f /etc/chromium/policies/managed/color.json || true
        q chromium --no-startup-window --set-theme-color="$theme_rgb_color" || true

        if [[ -f "$CURRENT_THEME_DIR/light.mode" ]]; then
            q chromium --no-startup-window --set-color-scheme="light" || true
        else
            q chromium --no-startup-window --set-color-scheme="dark" || true
        fi
    fi

    # Update helium-browser
    if command -v helium-browser &>/dev/null; then
        q bash -c "echo '{\"BrowserThemeColor\": \"$theme_hex_color\"}' | tee /etc/chromium/policies/managed/color.json >/dev/null" || true
        q helium-browser --no-startup-window --refresh-platform-policy || true
    fi
}

print_theme() {
    if [[ -L "$CURRENT_THEME_DIR" ]]; then
        basename "$(readlink "$CURRENT_THEME_DIR")"
    else
        echo "Error: No theme set" >&2
        return 1
    fi
}

#──────────────────────────────────────────────────────────────────────────────
# Font Functions
#──────────────────────────────────────────────────────────────────────────────

set_font() {
    local font_name=$1

    # Validate font exists (use grep without -q to avoid SIGPIPE with pipefail)
    if ! fc-list | grep -i "$font_name" >/dev/null; then
        echo "Error: Font '$font_name' not found" >&2
        echo "Use 'system-theme font list' to see available fonts" >&2
        return 1
    fi

    # Update alacritty
    if [[ -f "$HOME/.config/alacritty/alacritty.toml" ]]; then
        q sed -i "s/family = \"[^\"]*\"/family = \"$font_name\"/g" "$HOME/.config/alacritty/alacritty.toml" || true
    fi

    # Update waybar
    if [[ -f "$HOME/.config/waybar/style.css" ]]; then
        q sed -i "s/font-family: \"[^\"]*\"/font-family: \"$font_name\"/g" "$HOME/.config/waybar/style.css" || true
    fi

    # Update swayosd
    if [[ -f "$HOME/.config/swayosd/style.css" ]]; then
        q sed -i "s/font-family: \"[^\"]*\"/font-family: \"$font_name\"/g" "$HOME/.config/swayosd/style.css" || true
    fi

    # Update wlogout
    if [[ -f "$HOME/.config/wlogout/style.css" ]]; then
        q sed -i "s/font-family: \"[^\"]*\"/font-family: \"$font_name\"/g" "$HOME/.config/wlogout/style.css" || true
    fi

    # Update hyprland
    if [[ -f "$HOME/.config/hypr/core/style.conf" ]]; then
        q sed -i "s/font_family = .*/font_family = $font_name/g" "$HOME/.config/hypr/core/style.conf" || true
    fi

    # Update mako
    if [[ -f "$HOME/.config/mako/config" ]]; then
        q sed -i "s/font=.*/font=$font_name/g" "$HOME/.config/mako/config" || true
    fi

    # Update ghostty
    if [[ -f "$HOME/.config/ghostty/config" ]]; then
        q sed -i "s/font-family = .*/font-family = $font_name/g" "$HOME/.config/ghostty/config" || true
        q pkill -SIGUSR2 ghostty || true
    fi

    # Update zathura
    if [[ -f "$HOME/.config/zathura/zathurarc" ]]; then
        q sed -i "s/^set font \".*\"$/set font \"$font_name 15\"/g" "$HOME/.config/zathura/zathurarc" || true
    fi

    # Update fontconfig
    if [[ -f "$HOME/.config/fontconfig/fonts.conf" ]] && command -v xmlstarlet &>/dev/null; then
        q xmlstarlet ed -L \
            -u '//match[@target="pattern"][test/string="monospace"]/edit[@name="family"]/string' \
            -v "$font_name" \
            "$HOME/.config/fontconfig/fonts.conf" || true
    fi

    # Refresh applications if system-refresh is available
    if command -v system-refresh &>/dev/null; then
        q system-refresh apps || true
        q system-refresh theme || true
    fi

    echo "Font set to $font_name"
}

get_font() {
    # Try to extract from waybar style.css
    if [[ -f "$HOME/.config/waybar/style.css" ]]; then
        local font=$(grep -oP 'font-family:\s*["'\'']?\K[^;"'\'']+' "$HOME/.config/waybar/style.css" | head -n1)
        if [[ -n "$font" ]]; then
            echo "$font"
            return 0
        fi
    fi

    echo "Error: Unable to determine current font" >&2
    return 1
}

list_fonts() {
    # List monospace fonts, excluding emoji and signwriting fonts
    fc-list :spacing=100 -f "%{family[0]}\n" | grep -v -i -E 'emoji|signwriting' | sort -u
}

#──────────────────────────────────────────────────────────────────────────────
# Nightlight Functions
#──────────────────────────────────────────────────────────────────────────────

toggle_nightlight() {
    # Default temperature values
    local ON_TEMP=4000
    local OFF_TEMP=6500

    # Ensure hyprsunset is running
    if ! pgrep -x hyprsunset >/dev/null 2>&1; then
        setsid uwsm app -- hyprsunset &>/dev/null &
    fi

    # Query the current temperature
    local CURRENT_TEMP
    CURRENT_TEMP=$(hyprctl hyprsunset temperature 2>/dev/null | grep -oE '[0-9]+')

    if [[ "$CURRENT_TEMP" == "$ON_TEMP" ]]; then
        hyprctl --quiet hyprsunset temperature $OFF_TEMP
        notify-send " Daylight screen temperature"
    else
        hyprctl -q hyprsunset temperature $ON_TEMP
        notify-send " Nightlight screen temperature"
    fi
}

#──────────────────────────────────────────────────────────────────────────────
# Background Functions
#──────────────────────────────────────────────────────────────────────────────

get_available_backgrounds() {
    [[ -d "$THEME_BACKGROUNDS" ]] || {
        echo "Error: No backgrounds directory found in current theme" >&2
        return 1
    }

    local -n bg_array=$1
    mapfile -t bg_array < <(find "$THEME_BACKGROUNDS" -type f \( -name "*.jpg" -o -name "*.png" -o -name "*.jpeg" \) | sort)

    [[ ${#bg_array[@]} -gt 0 ]] || {
        echo "Error: No background images found in theme" >&2
        return 1
    }
}

apply_background() {
    local bg_path="$1"

    [[ -f "$bg_path" ]] || {
        echo "Error: Background file not found: $bg_path" >&2
        return 1
    }

    q ln -sf "$bg_path" "$HYPR_BACKGROUND"

    # Reload awww if it's running
    if command -v awww &>/dev/null && pgrep -x awww-daemon >/dev/null 2>&1; then
        q awww img "$HYPR_BACKGROUND" --transition-type fade --transition-duration 0.5
    fi

    echo "Background set to: $(basename "$bg_path")"
}

shuffle_background() {
    local -a bg_files
    get_available_backgrounds bg_files || return 1

    # If only one background, use it
    if [[ ${#bg_files[@]} -eq 1 ]]; then
        apply_background "${bg_files[0]}"
        return
    fi

    # Get current background basename
    local current_bg_basename=""
    if [[ -L "$HYPR_BACKGROUND" ]]; then
        current_bg_basename=$(basename "$(readlink "$HYPR_BACKGROUND")")
    fi

    # Filter out current background and pick random from remaining
    local -a available_bgs=()
    for bg in "${bg_files[@]}"; do
        if [[ "$(basename "$bg")" != "$current_bg_basename" ]]; then
            available_bgs+=("$bg")
        fi
    done

    # Pick random background
    if [[ ${#available_bgs[@]} -gt 0 ]]; then
        local selected_bg="${available_bgs[RANDOM % ${#available_bgs[@]}]}"
    else
        # Fallback: pick any random one
        local selected_bg="${bg_files[RANDOM % ${#bg_files[@]}]}"
    fi

    apply_background "$selected_bg"
}

next_background() {
    local -a bg_files
    get_available_backgrounds bg_files || return 1

    # If only one background, use it
    if [[ ${#bg_files[@]} -eq 1 ]]; then
        apply_background "${bg_files[0]}"
        return
    fi

    # Get current background path
    local current_bg=""
    if [[ -L "$HYPR_BACKGROUND" ]]; then
        current_bg=$(readlink "$HYPR_BACKGROUND")
    fi

    # Find current index
    local current_idx=-1
    for i in "${!bg_files[@]}"; do
        if [[ "${bg_files[$i]}" == "$current_bg" ]]; then
            current_idx=$i
            break
        fi
    done

    # Get next index (wrap around)
    local next_idx=$(((current_idx + 1) % ${#bg_files[@]}))

    apply_background "${bg_files[$next_idx]}"
}

set_background() {
    local bg_path="$1"

    # Handle relative and absolute paths
    if [[ ! "$bg_path" = /* ]]; then
        bg_path="$(pwd)/$bg_path"
    fi

    apply_background "$bg_path"
}

get_background() {
    if [[ -L "$HYPR_BACKGROUND" ]]; then
        readlink "$HYPR_BACKGROUND"
    else
        echo "Error: No background set" >&2
        return 1
    fi
}

#──────────────────────────────────────────────────────────────────────────────
# Help Functions
#──────────────────────────────────────────────────────────────────────────────

print_help() {
    cat <<EOF
Usage: system-theme <command> [arguments]

Commands:
  set THEME          Set theme to THEME (automatically applies to running apps)
  get                Print current theme name
  background, bg     Manage background images (see 'system-theme background help')
  font               Manage fonts (see 'system-theme font help')
  nightlight         Toggle nightlight mode (changes screen temperature)
  help               Show this help

Examples:
  system-theme set gruvbox
  system-theme get
  system-theme background shuffle
  system-theme font set "JetBrains Mono"
  system-theme nightlight
EOF
}

print_background_help() {
    cat <<EOF
Usage: system-theme background <action> [arguments]

Actions:
  shuffle            Set random background from current theme
  next               Set next background in sequence
  set PATH           Set specific background image
  get                Print current background path
  help               Show this help

Examples:
  system-theme background shuffle
  system-theme background next
  system-theme background set ~/Pictures/wallpaper.jpg
  system-theme background get
EOF
}

print_font_help() {
    cat <<EOF
Usage: system-theme font <action> [arguments]

Actions:
  set NAME           Set font to NAME (applies to all applications)
  get                Print current font name
  list               List available monospace fonts
  help               Show this help

Examples:
  system-theme font set "JetBrains Mono"
  system-theme font get
  system-theme font list
EOF
}

main "$@"
