#!/usr/bin/env bash
set -euo pipefail

#──────────────────────────────────────────────────────────────────────────────
# run-notify - Orchestrator for running scripts with notifications
#
# Runs a command, captures output, and sends desktop notifications:
# - Success: Shows last line of stdout (or "Done" if empty)
# - Failure: Shows error notification with stderr excerpt, logs full output
#
# Usage: run-notify <command> [args...]
# Example: run-notify system-theme set gruvbox
#──────────────────────────────────────────────────────────────────────────────

LOG_DIR="/tmp/dotfiles"
NOTIFY_TIMEOUT=5000 # milliseconds

# Temp files (global for cleanup)
_STDOUT_FILE=""
_STDERR_FILE=""

cleanup() {
    [[ -z "$_STDOUT_FILE" ]] || rm -f "$_STDOUT_FILE"
    [[ -z "$_STDERR_FILE" ]] || rm -f "$_STDERR_FILE"
}
trap cleanup EXIT

main() {
    [[ $# -gt 0 ]] || {
        print_help
        exit 1
    }

    local cmd_name
    cmd_name=$(basename "$1")

    run_with_notification "$cmd_name" "$@"
}

run_with_notification() {
    local cmd_name="$1"
    shift

    local start_time end_time duration
    local exit_code=0

    # Create temp files for capturing output
    _STDOUT_FILE=$(mktemp)
    _STDERR_FILE=$(mktemp)

    # Run command and capture output
    start_time=$(date +%s.%N)

    # Run command, capturing stdout and stderr separately
    set +e # allow the script to fail
    "$@" >"$_STDOUT_FILE" 2>"$_STDERR_FILE"
    exit_code=$?
    set -e

    end_time=$(date +%s.%N)
    duration=$(printf "%.1fs" "$(echo "$end_time - $start_time" | bc)")

    if [[ $exit_code -eq 0 ]]; then
        handle_success "$cmd_name" "$duration"
    else
        handle_failure "$cmd_name" "$duration" "$exit_code"
    fi

    return $exit_code
}

handle_success() {
    local cmd_name="$1"
    local duration="$2"

    # Get last non-empty line of stdout for the notification body
    local last_line
    last_line=$(grep -v '^[[:space:]]*$' "$_STDOUT_FILE" | tail -n1 || true)

    # Default message if stdout was empty
    [[ -n "$last_line" ]] || last_line="Done"

    notify-send \
        --app-name="$cmd_name" \
        --expire-time="$NOTIFY_TIMEOUT" \
        "$cmd_name ($duration)" \
        "$last_line"
}

handle_failure() {
    local cmd_name="$1"
    local duration="$2"
    local exit_code="$3"

    # Log full output on error
    local log_file
    log_file=$(log_error "$cmd_name" "$exit_code")

    # Get error message for notification
    # Prefer stderr, fall back to stdout, then generic message
    local error_msg
    if [[ -s "$_STDERR_FILE" ]]; then
        error_msg=$(tail -n3 "$_STDERR_FILE" | head -c 200)
    elif [[ -s "$_STDOUT_FILE" ]]; then
        error_msg=$(tail -n3 "$_STDOUT_FILE" | head -c 200)
    else
        error_msg="Command failed with exit code $exit_code"
    fi

    notify-send \
        --app-name="$cmd_name" \
        --urgency=critical \
        --expire-time=0 \
        "$cmd_name failed ($duration)" \
        "$error_msg

Log: $log_file"
}

log_error() {
    local cmd_name="$1"
    local exit_code="$2"

    mkdir -p "$LOG_DIR"

    local timestamp
    timestamp=$(date +%Y%m%d-%H%M%S)
    local log_file="$LOG_DIR/${cmd_name}-${timestamp}.log"

    {
        echo "Command: $cmd_name"
        echo "Exit code: $exit_code"
        echo "Timestamp: $(date)"
        echo ""
        echo "=== STDOUT ==="
        cat "$_STDOUT_FILE"
        echo ""
        echo "=== STDERR ==="
        cat "$_STDERR_FILE"
    } >"$log_file"

    echo "$log_file"
}

print_help() {
    cat <<EOF
Usage: run-notify <command> [args...]

Runs a command and sends a desktop notification with the result.

On success:
  - Shows the last line of stdout (or "Done" if empty)
  - Notification title includes command name and duration

On failure:
  - Shows critical notification with error excerpt
  - Logs full stdout/stderr to $LOG_DIR/<command>-<timestamp>.log
  - Notification includes path to log file

Examples:
  run-notify system-theme set gruvbox
  run-notify system-refresh
  run-notify dotfiles-update

Options:
  --help, -h    Show this help
EOF
}

# Handle --help before main
case "${1:-}" in
--help | -h | help)
    print_help
    exit 0
    ;;
esac

main "$@"
