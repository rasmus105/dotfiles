#!/usr/bin/env bash
set -euo pipefail

#──────────────────────────────────────────────────────────────────────────────
# Setup
#──────────────────────────────────────────────────────────────────────────────

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "${SCRIPT_DIR}/../lib/shell/common.sh" 2>/dev/null || q() { "$@" >/dev/null 2>&1; }

DOTFILES_DIR="$(cd "${SCRIPT_DIR}/../.." && pwd)"

#──────────────────────────────────────────────────────────────────────────────
# Functions
#──────────────────────────────────────────────────────────────────────────────

main() {
    parse_args "$@"
}

parse_args() {
    [[ $# -gt 0 ]] || {
        print_help
        exit 0
    }

    local action="$1"
    shift

    case "$action" in
    update)
        [[ $# -eq 0 ]] || {
            echo "Error: update takes no arguments" >&2
            exit 1
        }
        full_update
        ;;
    update-git)
        [[ $# -eq 0 ]] || {
            echo "Error: update-git takes no arguments" >&2
            exit 1
        }
        update_git
        ;;
    install-package)
        [[ $# -eq 0 ]] || {
            echo "Error: install-package takes no arguments" >&2
            exit 1
        }
        install_package
        ;;
    remove-package)
        [[ $# -eq 0 ]] || {
            echo "Error: remove-package takes no arguments" >&2
            exit 1
        }
        remove_package
        ;;
    --help | -h | help)
        [[ $# -eq 0 ]] || {
            echo "Error: help takes no arguments" >&2
            exit 1
        }
        print_help
        ;;
    *)
        echo "Error: Unknown action: $action" >&2
        print_help
        exit 1
        ;;
    esac
}

#──────────────────────────────────────────────────────────────────────────────
# Update Functions
#──────────────────────────────────────────────────────────────────────────────

update_git() {
    cd "$DOTFILES_DIR"

    echo "Updating dotfiles from git..."

    # Check for uncommitted changes
    if [[ -n $(git status --porcelain) ]]; then
        echo "Error: You have uncommitted changes in your dotfiles" >&2
        echo "Commit or stash your changes first" >&2
        git status --short >&2
        return 1
    fi

    # Fetch updates
    echo "Fetching updates..."
    if ! q git fetch origin; then
        echo "Error: Failed to fetch from remote" >&2
        return 1
    fi

    # Check for updates
    local current_branch
    current_branch=$(git rev-parse --abbrev-ref HEAD)
    
    local upstream="origin/$current_branch"
    if ! git rev-parse "$upstream" &>/dev/null; then
        echo "No upstream branch found for '$current_branch'"
        return 0
    fi

    local local_commit remote_commit base_commit
    local_commit=$(git rev-parse @)
    remote_commit=$(git rev-parse "$upstream")
    base_commit=$(git merge-base @ "$upstream")

    if [[ "$local_commit" == "$remote_commit" ]]; then
        echo "Dotfiles already up to date"
        return 0
    elif [[ "$local_commit" == "$base_commit" ]]; then
        # We're behind, can fast-forward
        local commits_behind
        commits_behind=$(git rev-list --count "$local_commit..$remote_commit")
        echo "Pulling $commits_behind commit(s)..."

        local old_commit
        old_commit=$(git rev-parse HEAD)

        if ! q git pull origin "$current_branch"; then
            echo "Error: Failed to pull updates" >&2
            return 1
        fi

        echo "Successfully pulled updates"

        # Run stow
        echo "Updating symlinks..."
        stow_dotfiles

        # Update system configs
        update_system_configs

        # Run pre-install.sh if it exists
        if [[ -f "$DOTFILES_DIR/install/pre-install.sh" ]]; then
            echo "Running pre-install migrations..."
            if ! bash "$DOTFILES_DIR/install/pre-install.sh"; then
                echo "Warning: pre-install script failed" >&2
            fi
        fi

        # Refresh system
        if command -v system-refresh &>/dev/null; then
            echo "Refreshing system..."
            q system-refresh || echo "Warning: system-refresh failed" >&2
        fi

        echo "Dotfiles updated successfully"
    elif [[ "$remote_commit" == "$base_commit" ]]; then
        # We're ahead of remote
        echo "Your dotfiles are ahead of remote"
        echo "Consider pushing your changes"
        return 0
    else
        # Diverged
        echo "Error: Your branch has diverged from remote" >&2
        echo "Resolve manually with: git pull --rebase or git merge" >&2
        return 1
    fi
}

full_update() {
    echo "Starting full system update..."
    echo

    # Check for multiple running instances
    if [[ $(pgrep -fc "dotfiles update") -gt 1 ]]; then
        echo "Error: Update is already running" >&2
        return 1
    fi

    # Cache sudo credentials
    if ! sudo -v; then
        echo "Error: Failed to obtain sudo credentials" >&2
        return 1
    fi

    # Keep sudo alive in background
    while sleep 100; do sudo -v; done &
    local sudo_pid=$!
    trap "kill $sudo_pid 2>/dev/null || true" EXIT

    # Update dotfiles
    echo "==> Updating dotfiles..."
    update_git || echo "Warning: Dotfiles update had issues" >&2
    echo

    # Update system packages
    echo "==> Updating system packages..."
    if command -v paru &>/dev/null; then
        q paru -Syu --noconfirm || {
            echo "Error: System update failed" >&2
            kill $sudo_pid 2>/dev/null || true
            return 1
        }
    else
        q sudo pacman -Syu --noconfirm || {
            echo "Error: System update failed" >&2
            kill $sudo_pid 2>/dev/null || true
            return 1
        }
    fi
    echo "System packages updated"
    echo

    # Update flatpak
    if command -v flatpak &>/dev/null; then
        echo "==> Updating Flatpak packages..."
        q flatpak update -y || echo "Warning: Flatpak update had issues" >&2
        echo
    fi

    # Check for orphaned packages
    echo "==> Checking for orphaned packages..."
    local orphans
    orphans=$(pacman -Qtdq 2>/dev/null || true)

    if [[ -n "$orphans" ]]; then
        local orphan_count
        orphan_count=$(echo "$orphans" | wc -l)
        echo "Found $orphan_count orphaned package(s):"
        echo "$orphans"
        echo
        echo "Run 'sudo pacman -Rns \$(pacman -Qtdq)' to remove them"
    else
        echo "No orphaned packages found"
    fi
    echo

    # Check for kernel update
    local running_kernel installed_kernel
    running_kernel=$(uname -r | sed 's/-/./g')
    installed_kernel=$( (pacman -Q linux 2>/dev/null | awk '{print $2}' || echo "unknown") | sed 's/-/./g')

    if [[ "$running_kernel" != "$installed_kernel" ]]; then
        echo "WARNING: Linux kernel has been updated"
        echo "Running: $running_kernel"
        echo "Installed: $installed_kernel"
        echo "Reboot recommended to use the new kernel"
        echo
    fi

    # Clean up sudo background process
    kill $sudo_pid 2>/dev/null || true
    trap - EXIT

    echo "System update completed successfully"
}

stow_dotfiles() {
    cd "$DOTFILES_DIR"

    # Stow config, home, and local directories
    q stow --restow -t "$HOME/.config" config || {
        echo "Error: Failed to stow config directory" >&2
        return 1
    }
    
    q stow --restow -t "$HOME" home || {
        echo "Error: Failed to stow home directory" >&2
        return 1
    }

    q mkdir -p "$HOME/.local/share/applications/icons"
    q stow --restow -t "$HOME/.local" local || {
        echo "Error: Failed to stow local directory" >&2
        return 1
    }

    # Set default theme if not set
    if [[ ! -e "$HOME/.config/theme" ]]; then
        if command -v system-theme &>/dev/null; then
            q system-theme set gruvbox || true
        fi
    fi
}

update_system_configs() {
    # Copy system configs with rsync
    if sudo -n true 2>/dev/null; then
        q sudo rsync -av "$DOTFILES_DIR/system/" / || {
            echo "Warning: Failed to update system configs" >&2
        }
    else
        echo "Warning: Cannot update system configs without sudo" >&2
    fi
}

#──────────────────────────────────────────────────────────────────────────────
# Package Functions
#──────────────────────────────────────────────────────────────────────────────

format_packages() {
    awk '{
        colors["core"] = "\033[34m"
        colors["extra"] = "\033[32m"
        colors["aur"] = "\033[33m"
        color = ($1 in colors) ? colors[$1] : "\033[0m"
        installed = ($4 == "[installed]") ? " \033[90m✓\033[0m" : ""
        printf "%s[%s]\033[0m %s%s\n", color, $1, $2, installed
    }'
}

install_package() {
    # Check for required tools
    if ! command -v fzf &>/dev/null; then
        echo "Error: fzf is not installed" >&2
        return 1
    fi

    local fzf_args=(
        --multi
        --ansi
        --preview 'paru -Si {2}'
        --preview-label='Space/Tab: select, Enter: confirm, Ctrl-p: toggle preview'
        --preview-label-pos='bottom'
        --preview-window 'right:60%:wrap'
        --bind 'ctrl-p:toggle-preview'
        --bind 'ctrl-d:preview-half-page-down,ctrl-u:preview-half-page-up'
        --bind 'ctrl-f:half-page-down,ctrl-b:half-page-up'
        --bind 'space:toggle'
        --bind 'ctrl-space:toggle'
        --color 'pointer:green,marker:green'
        --header='Select packages to install'
    )

    # Select packages with FZF
    local selected
    selected=$(pacman -Sl | format_packages | fzf "${fzf_args[@]}" | awk '{print $2}')

    if [[ -z "$selected" ]]; then
        echo "No packages selected"
        return 0
    fi

    # Show what will be installed
    local pkg_count
    pkg_count=$(echo "$selected" | wc -l)
    echo
    echo "Installing $pkg_count package(s):"
    echo "$selected" | while read -r pkg; do
        echo "  + $pkg"
    done
    echo

    # Confirm installation
    read -p "Install these packages? [y/N] " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        echo "Cancelled"
        return 0
    fi

    # Install packages
    local pkg_list
    pkg_list=$(echo "$selected" | tr '\n' ' ')
    
    echo "Installing packages..."
    if command -v paru &>/dev/null; then
        paru -S --noconfirm $pkg_list
    else
        sudo pacman -S --noconfirm $pkg_list
    fi

    if [[ $? -eq 0 ]]; then
        echo "Updating file database..."
        q sudo updatedb || true
        echo "Packages installed successfully"
    else
        echo "Error: Package installation failed" >&2
        return 1
    fi
}

remove_package() {
    # Check for required tools
    if ! command -v fzf &>/dev/null; then
        echo "Error: fzf is not installed" >&2
        return 1
    fi

    local fzf_args=(
        --multi
        --preview 'paru -Qi {1}'
        --preview-label='Space/Tab: select, Enter: confirm, Ctrl-p: toggle preview'
        --preview-label-pos='bottom'
        --preview-window 'right:60%:wrap'
        --bind 'ctrl-p:toggle-preview'
        --bind 'ctrl-d:preview-half-page-down,ctrl-u:preview-half-page-up'
        --bind 'ctrl-f:half-page-down,ctrl-b:half-page-up'
        --bind 'space:toggle'
        --bind 'ctrl-space:toggle'
        --color 'pointer:red,marker:red'
        --header='Select packages to remove'
    )

    # Select packages with FZF
    local selected
    selected=$(paru -Qqe | fzf "${fzf_args[@]}")

    if [[ -z "$selected" ]]; then
        echo "No packages selected"
        return 0
    fi

    # Show what will be removed
    local pkg_count
    pkg_count=$(echo "$selected" | wc -l)
    echo
    echo "Removing $pkg_count package(s):"
    echo "$selected" | while read -r pkg; do
        echo "  ✗ $pkg"
    done
    echo

    # Confirm removal
    read -p "Remove these packages? [y/N] " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        echo "Cancelled"
        return 0
    fi

    # Remove packages
    local pkg_list
    pkg_list=$(echo "$selected" | tr '\n' ' ')
    
    echo "Removing packages..."
    sudo pacman -Rns --noconfirm $pkg_list

    if [[ $? -eq 0 ]]; then
        echo "Packages removed successfully"
    else
        echo "Error: Package removal failed" >&2
        return 1
    fi
}

#──────────────────────────────────────────────────────────────────────────────
# Help Functions
#──────────────────────────────────────────────────────────────────────────────

print_help() {
    cat <<EOF
Usage: dotfiles <command>

Commands:
  update             Full system update (dotfiles + packages + flatpak)
  update-git         Update dotfiles from git and run stow (no package update)
  install-package    Install packages with fzf selection
  remove-package     Remove packages with fzf selection
  help               Show this help

Examples:
  dotfiles update              # Update everything
  dotfiles update-git          # Just update dotfiles
  dotfiles install-package     # Interactive package installation
  dotfiles remove-package      # Interactive package removal

Description:
  update         - Updates dotfiles from git, system packages (pacman/AUR),
                   flatpak packages, checks for orphans and kernel updates
  
  update-git     - Only updates dotfiles from git repository and runs stow
                   to update symlinks. Does not update system packages.
  
  install-package - Interactive package installer using fzf for selection
                    with preview of package information
  
  remove-package  - Interactive package remover using fzf for selection
                    with preview of package information
EOF
}

main "$@"
