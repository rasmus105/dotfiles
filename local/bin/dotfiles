#!/usr/bin/env bash
set -euo pipefail

#──────────────────────────────────────────────────────────────────────────────
# Setup
#──────────────────────────────────────────────────────────────────────────────

# Source dotfiles environment for DOTFILES_DIR
if [[ -f "$HOME/.dotfiles_env" ]]; then
    source "$HOME/.dotfiles_env"
elif [[ -n "${DOTFILES_DIR:-}" ]]; then
    : # DOTFILES_DIR already set in environment
else
    # Fallback: derive from script location
    SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
    DOTFILES_DIR="$(cd "${SCRIPT_DIR}/../.." && pwd)"
fi

# Source common utilities
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "${SCRIPT_DIR}/../lib/shell/common.sh" 2>/dev/null || q() { "$@" >/dev/null 2>&1; }
source "${SCRIPT_DIR}/../lib/shell/completions.sh" 2>/dev/null || true

#──────────────────────────────────────────────────────────────────────────────
# Command Definitions (single source of truth for help + completions)
#──────────────────────────────────────────────────────────────────────────────

declare -gA COMMANDS=(
    [update]="Full system update (dotfiles + packages + flatpak)"
    [update-git]="Update dotfiles from git and run stow (no package update)"
    [update-git-stash]="Same as update-git but stash/pop changes automatically"
    [install-package]="Install packages with fzf selection"
    [remove-package]="Remove packages with fzf selection"
    [help]="Show this help"
)

# Track background processes for cleanup
SUDO_PID=""

#──────────────────────────────────────────────────────────────────────────────
# Utility Functions
#──────────────────────────────────────────────────────────────────────────────

cleanup() {
    if [[ -n "$SUDO_PID" ]] && kill -0 "$SUDO_PID" 2>/dev/null; then
        kill "$SUDO_PID" 2>/dev/null || true
    fi
}

die() {
    echo "Error: $1" >&2
    exit 1
}

warn() {
    echo "Warning: $1" >&2
}

# Common fzf arguments for package selection
get_fzf_args() {
    local color="$1"
    local header="$2"
    local preview_cmd="$3"

    echo "--multi"
    echo "--ansi"
    echo "--preview"
    echo "$preview_cmd"
    echo "--preview-label=Space/Tab: select, Enter: confirm, Ctrl-p: toggle preview"
    echo "--preview-label-pos=bottom"
    echo "--preview-window=right:60%:wrap"
    echo "--bind=ctrl-p:toggle-preview"
    echo "--bind=ctrl-d:preview-half-page-down,ctrl-u:preview-half-page-up"
    echo "--bind=ctrl-f:half-page-down,ctrl-b:half-page-up"
    echo "--bind=space:toggle"
    echo "--bind=ctrl-space:toggle"
    echo "--color=pointer:$color,marker:$color"
    echo "--header=$header"
}

#──────────────────────────────────────────────────────────────────────────────
# Main & Argument Parsing
#──────────────────────────────────────────────────────────────────────────────

main() {
    parse_args "$@"
}

parse_args() {
    # Handle completions request
    if [[ "${1:-}" == "--completions" ]]; then
        handle_completions "$@" && exit 0 || exit 1
    fi

    if [[ $# -eq 0 ]]; then
        print_help
        exit 0
    fi

    local action="$1"
    shift

    # Commands that take no arguments
    case "$action" in
    update | update-git | update-git-stash | install-package | remove-package | --help | -h | help)
        if [[ $# -gt 0 ]]; then
            die "$action takes no arguments"
        fi
        ;;
    esac

    case "$action" in
    update) full_update ;;
    update-git) update_git ;;
    update-git-stash) update_git_with_stash ;;
    install-package) install_package ;;
    remove-package) remove_package ;;
    --help | -h | help) print_help ;;
    *)
        echo "Error: Unknown action: $action" >&2
        print_help
        exit 1
        ;;
    esac
}

#──────────────────────────────────────────────────────────────────────────────
# Update Functions
#──────────────────────────────────────────────────────────────────────────────

update_git() {
    cd "$DOTFILES_DIR"

    echo "Updating dotfiles from git..."

    # Check for uncommitted changes
    if [[ -n $(git status --porcelain) ]]; then
        echo "Error: You have uncommitted changes in your dotfiles" >&2
        echo "Commit or stash your changes first" >&2
        git status --short >&2
        return 1
    fi

    # Fetch updates
    echo "Fetching updates..."
    if ! q git fetch origin; then
        echo "Error: Failed to fetch from remote" >&2
        return 1
    fi

    # Check for updates
    local current_branch
    current_branch=$(git rev-parse --abbrev-ref HEAD)

    local upstream="origin/$current_branch"
    if ! git rev-parse "$upstream" &>/dev/null; then
        echo "No upstream branch found for '$current_branch'"
        return 0
    fi

    local local_commit remote_commit base_commit
    local_commit=$(git rev-parse @)
    remote_commit=$(git rev-parse "$upstream")
    base_commit=$(git merge-base @ "$upstream")

    if [[ "$local_commit" == "$remote_commit" ]]; then
        echo "Dotfiles already up to date"
        return 0
    elif [[ "$local_commit" == "$base_commit" ]]; then
        # We're behind, can fast-forward
        local commits_behind
        commits_behind=$(git rev-list --count "$local_commit..$remote_commit")
        echo "Pulling $commits_behind commit(s)..."

        if ! q git pull origin "$current_branch"; then
            echo "Error: Failed to pull updates" >&2
            return 1
        fi

        echo "Successfully pulled updates"

        # Run stow
        echo "Updating symlinks..."
        stow_dotfiles

        # Update system configs
        update_system_configs

        # Run pre-install.sh if it exists
        if [[ -f "$DOTFILES_DIR/install/pre-install.sh" ]]; then
            echo "Running pre-install migrations..."
            if ! bash "$DOTFILES_DIR/install/pre-install.sh"; then
                warn "pre-install script failed"
            fi
        fi

        # Refresh system
        if command -v system-refresh &>/dev/null; then
            echo "Refreshing system..."
            q system-refresh || warn "system-refresh failed"
        fi

        echo "Dotfiles updated successfully"
    elif [[ "$remote_commit" == "$base_commit" ]]; then
        # We're ahead of remote
        echo "Your dotfiles are ahead of remote"
        echo "Consider pushing your changes"
        return 0
    else
        # Diverged
        echo "Error: Your branch has diverged from remote" >&2
        echo "Resolve manually with: git pull --rebase or git merge" >&2
        return 1
    fi
}

# Update dotfiles with automatic stash/pop
# Exit codes:
#   0 = success (including successful stash pop)
#   1 = general failure (fetch failed, diverged, etc.)
#   2 = pull succeeded but stash pop failed (conflicts)
update_git_with_stash() {
    cd "$DOTFILES_DIR"

    # Check if there are changes to stash (tracked files only)
    if git diff --quiet 2>/dev/null && git diff --cached --quiet 2>/dev/null; then
        echo "No changes to stash, running normal update..."
        update_git
        return $?
    fi

    # Stash changes (including untracked files)
    echo "Stashing local changes..."
    local stash_msg="dotfiles auto-stash: $(date '+%Y-%m-%d %H:%M:%S')"
    if ! git stash push -u -m "$stash_msg"; then
        echo "Error: Failed to stash changes" >&2
        return 1
    fi

    # Run normal update (capture result, don't exit on failure)
    local update_result=0
    update_git || update_result=$?

    # Pop stash (whether update succeeded or failed)
    if ! git stash pop; then
        if [[ $update_result -eq 0 ]]; then
            # Update succeeded but pop failed - this is the conflict case
            echo "Warning: Stash pop failed (likely conflicts)" >&2
            echo "Your changes are saved in git stash" >&2
            echo "Run 'git stash show' to see stashed changes" >&2
            echo "Run 'git stash pop' to restore them manually" >&2
            return 2
        else
            # Update failed and pop failed
            echo "Warning: Could not restore stashed changes" >&2
            echo "Your changes are saved in git stash" >&2
            return 1
        fi
    fi

    return $update_result
}

full_update() {
    # Acquire lock (non-blocking)
    local lock_file="/tmp/dotfiles-update.lock"
    exec 9>"$lock_file"
    if ! flock -n 9; then
        die "Update is already running"
    fi

    echo "Starting full system update..."
    echo

    # Cache sudo credentials
    if ! sudo -v; then
        die "Failed to obtain sudo credentials"
    fi

    # Keep sudo alive in background
    while sleep 100; do sudo -v; done &
    SUDO_PID=$!
    trap cleanup EXIT INT TERM

    # Update dotfiles
    echo "==> Updating dotfiles..."
    update_git || warn "Dotfiles update had issues"
    echo

    # Update system packages
    echo "==> Updating system packages..."
    if command -v paru &>/dev/null; then
        if ! q paru -Syu --noconfirm; then
            cleanup
            die "System update failed"
        fi
    else
        if ! q sudo pacman -Syu --noconfirm; then
            cleanup
            die "System update failed"
        fi
    fi
    echo "System packages updated"
    echo

    # Update flatpak
    if command -v flatpak &>/dev/null; then
        echo "==> Updating Flatpak packages..."
        q flatpak update -y || warn "Flatpak update had issues"
        echo
    fi

    # Check for orphaned packages
    echo "==> Checking for orphaned packages..."
    local orphans
    orphans=$(pacman -Qtdq 2>/dev/null || true)

    if [[ -n "$orphans" ]]; then
        local orphan_count
        orphan_count=$(echo "$orphans" | wc -l)
        echo "Found $orphan_count orphaned package(s):"
        echo "$orphans"
        echo
        echo "Run 'sudo pacman -Rns \$(pacman -Qtdq)' to remove them"
    else
        echo "No orphaned packages found"
    fi
    echo

    # Check for kernel update
    local running_kernel installed_kernel
    running_kernel=$(uname -r | sed 's/-/./g')
    installed_kernel=$( (pacman -Q linux 2>/dev/null | awk '{print $2}' || echo "unknown") | sed 's/-/./g')

    if [[ "$running_kernel" != "$installed_kernel" ]]; then
        echo "WARNING: Linux kernel has been updated"
        echo "Running: $running_kernel"
        echo "Installed: $installed_kernel"
        echo "Reboot recommended to use the new kernel"
        echo
    fi

    cleanup
    trap - EXIT INT TERM

    echo "System update completed successfully"
}

stow_dotfiles() {
    cd "$DOTFILES_DIR"

    # Stow config, home, and local directories
    q stow --restow -t "$HOME/.config" config || {
        warn "Failed to stow config directory"
        return 1
    }

    q stow --restow -t "$HOME" home || {
        warn "Failed to stow home directory"
        return 1
    }

    q mkdir -p "$HOME/.local/share/applications/icons"
    q stow --restow -t "$HOME/.local" local || {
        warn "Failed to stow local directory"
        return 1
    }

    # Set default theme if not set
    if [[ ! -e "$HOME/.config/theme" ]]; then
        if command -v system-theme &>/dev/null; then
            q system-theme set gruvbox || true
        fi
    fi
}

update_system_configs() {
    # Copy system configs with rsync
    if sudo -n true 2>/dev/null; then
        q sudo rsync -av "$DOTFILES_DIR/system/" / || {
            warn "Failed to update system configs"
        }
    else
        warn "Cannot update system configs without sudo"
    fi
}

#──────────────────────────────────────────────────────────────────────────────
# Package Functions
#──────────────────────────────────────────────────────────────────────────────

format_packages() {
    awk '{
        colors["core"] = "\033[34m"
        colors["extra"] = "\033[32m"
        colors["aur"] = "\033[33m"
        color = ($1 in colors) ? colors[$1] : "\033[0m"
        installed = ($4 == "[installed]") ? " \033[90m✓\033[0m" : ""
        printf "%s[%s]\033[0m %s%s\n", color, $1, $2, installed
    }'
}

install_package() {
    if ! command -v fzf &>/dev/null; then
        die "fzf is not installed"
    fi

    # Select packages with FZF
    local selected fzf_args
    mapfile -t fzf_args < <(get_fzf_args "green" "Select packages to install" "paru -Si {2}")

    selected=$(pacman -Sl | format_packages | fzf "${fzf_args[@]}" | awk '{print $2}') || true

    if [[ -z "$selected" ]]; then
        echo "No packages selected"
        return 0
    fi

    # Show what will be installed
    local pkg_count
    pkg_count=$(echo "$selected" | wc -l)
    echo
    echo "Installing $pkg_count package(s):"
    echo "$selected" | while read -r pkg; do
        echo "  + $pkg"
    done
    echo

    # Confirm installation
    read -p "Install these packages? [y/N] " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        echo "Cancelled"
        return 0
    fi

    # Convert to array for proper quoting
    local -a pkg_array
    mapfile -t pkg_array <<<"$selected"

    echo "Installing packages..."
    if command -v paru &>/dev/null; then
        paru -S --noconfirm "${pkg_array[@]}"
    else
        sudo pacman -S --noconfirm "${pkg_array[@]}"
    fi

    echo "Updating file database..."
    q sudo updatedb || true
    echo "Packages installed successfully"
}

remove_package() {
    if ! command -v fzf &>/dev/null; then
        die "fzf is not installed"
    fi

    # Select packages with FZF
    local selected fzf_args
    mapfile -t fzf_args < <(get_fzf_args "red" "Select packages to remove" "paru -Qi {1}")

    selected=$(paru -Qqe | fzf "${fzf_args[@]}") || true

    if [[ -z "$selected" ]]; then
        echo "No packages selected"
        return 0
    fi

    # Show what will be removed
    local pkg_count
    pkg_count=$(echo "$selected" | wc -l)
    echo
    echo "Removing $pkg_count package(s):"
    echo "$selected" | while read -r pkg; do
        echo "  - $pkg"
    done
    echo

    # Confirm removal
    read -p "Remove these packages? [y/N] " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        echo "Cancelled"
        return 0
    fi

    # Convert to array for proper quoting
    local -a pkg_array
    mapfile -t pkg_array <<<"$selected"

    echo "Removing packages..."
    sudo pacman -Rns --noconfirm "${pkg_array[@]}"

    echo "Packages removed successfully"
}

#──────────────────────────────────────────────────────────────────────────────
# Help Functions
#──────────────────────────────────────────────────────────────────────────────

print_help() {
    echo "Usage: dotfiles <command>"
    echo
    echo "Commands:"
    # Generate commands list from COMMANDS array
    for cmd in update update-git update-git-stash install-package remove-package help; do
        printf "  %-18s %s\n" "$cmd" "${COMMANDS[$cmd]}"
    done
    echo
    cat <<'EOF'
Examples:
  dotfiles update              # Update everything
  dotfiles update-git          # Just update dotfiles
  dotfiles install-package     # Interactive package installation
  dotfiles remove-package      # Interactive package removal
EOF
}

main "$@"
